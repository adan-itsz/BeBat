{
  "_args": [
    [
      {
        "raw": "nearley@^2.7.7",
        "scope": null,
        "escapedName": "nearley",
        "name": "nearley",
        "rawSpec": "^2.7.7",
        "spec": ">=2.7.7 <3.0.0",
        "type": "range"
      },
      "/home/adan/practicasWeb/beBat/node_modules/css-to-react-native"
    ]
  ],
  "_from": "nearley@>=2.7.7 <3.0.0",
  "_id": "nearley@2.10.0",
  "_inCache": true,
  "_location": "/nearley",
  "_nodeVersion": "7.7.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/nearley-2.10.0.tgz_1496798049354_0.8378930087201297"
  },
  "_npmUser": {
    "name": "hardmath123",
    "email": "hardmath123@comfortablynumbered.appspotmail.com"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "nearley@^2.7.7",
    "scope": null,
    "escapedName": "nearley",
    "name": "nearley",
    "rawSpec": "^2.7.7",
    "spec": ">=2.7.7 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/css-to-react-native"
  ],
  "_resolved": "https://registry.npmjs.org/nearley/-/nearley-2.10.0.tgz",
  "_shasum": "3ca2f086ea9e0477734e7801b015c51127df23cc",
  "_shrinkwrap": null,
  "_spec": "nearley@^2.7.7",
  "_where": "/home/adan/practicasWeb/beBat/node_modules/css-to-react-native",
  "author": {
    "name": "Hardmath123"
  },
  "bin": {
    "nearleyc": "bin/nearleyc.js",
    "nearley-test": "bin/nearley-test.js",
    "nearley-unparse": "bin/nearley-unparse.js",
    "nearley-railroad": "bin/nearley-railroad.js"
  },
  "bugs": {
    "url": "https://github.com/hardmath123/nearley/issues"
  },
  "contributors": "https://github.com/Hardmath123/nearley/graphs/contributors",
  "dependencies": {
    "nomnom": "~1.6.2",
    "railroad-diagrams": "^1.0.0",
    "randexp": "^0.4.2"
  },
  "description": "Simple, fast, powerful parser toolkit for JavaScript.",
  "devDependencies": {
    "@types/moo": "^0.3.0",
    "@types/node": "^7.0.27",
    "benchmark": "^2.1.3",
    "chai": "^3.4.1",
    "coffee-script": "^1.10.0",
    "microtime": "^2.1.2",
    "mocha": "^2.3.4",
    "moo": "^0.3.2",
    "typescript": "^2.3.4"
  },
  "directories": {},
  "dist": {
    "shasum": "3ca2f086ea9e0477734e7801b015c51127df23cc",
    "tarball": "https://registry.npmjs.org/nearley/-/nearley-2.10.0.tgz"
  },
  "gitHead": "3395fe9f10d99e29529d5a348928cc271f01236c",
  "homepage": "https://github.com/hardmath123/nearley#readme",
  "keywords": [
    "parser",
    "parse",
    "generator",
    "compiler",
    "compile",
    "grammar",
    "language"
  ],
  "license": "MIT",
  "main": "lib/nearley.js",
  "maintainers": [
    {
      "name": "hardmath123",
      "email": "hardmath123@comfortablynumbered.appspotmail.com"
    },
    {
      "name": "tjvr",
      "email": "tim@tjvr.org"
    }
  ],
  "name": "nearley",
  "optionalDependencies": {},
  "readme": "![](www/logo/nearley-purple.png)\n\n[nearley](http://nearley.js.org) [![JS.ORG](https://img.shields.io/badge/js.org-nearley-ffb400.svg?style=flat-square)](http://js.org)\n==============\n\nSimple parsing for node.js.\n\n<!-- $ npm install -g doctoc -->\n<!-- $ doctoc --notitle README.md -->\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [What is nearley?](#what-is-nearley)\n- [Why do I care?](#why-do-i-care)\n- [Installation and Usage](#installation-and-usage)\n- [Parser specification](#parser-specification)\n  - [Postprocessors](#postprocessors)\n  - [Epsilon rules](#epsilon-rules)\n  - [Charsets](#charsets)\n  - [EBNF](#ebnf)\n  - [Macros](#macros)\n  - [Additional JS](#additional-js)\n  - [Importing](#importing)\n  - [Custom tokens](#custom-tokens)\n- [Using a parser](#using-a-parser)\n- [Catching errors](#catching-errors)\n- [Exploring a parser interactively](#exploring-a-parser-interactively)\n- [The Unparser](#the-unparser)\n- [Automagical Railroad Diagrams](#automagical-railroad-diagrams)\n- [Other Tools](#other-tools)\n- [Still confused?](#still-confused)\n- [Contributing](#contributing)\n- [Further reading](#further-reading)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\nWhat is nearley?\n----------------\nnearley uses the Earley parsing algorithm augmented with Joop Leo's\noptimizations to parse complex data structures easily. nearley is über-fast and\nreally powerful. It can parse literally anything you throw at it.\n\nnearley is used by [artificial\nintelligence](https://github.com/ChalmersGU-AI-course/shrdlite-course-project)\nand [computational\nlinguistics](https://wiki.eecs.yorku.ca/course_archive/2014-15/W/6339/useful_handouts)\nclasses at universities, as well as [file format\nparsers](https://github.com/raymond-h/node-dmi), [markup\nlanguages](https://github.com/bobbybee/uPresent) and [complete programming\nlanguages](https://github.com/bobbybee/carbon). It's an npm [staff\npick](https://www.npmjs.com/package/npm-collection-staff-picks).\n\nWhy do I care?\n--------------\n\nnearley can parse what other JS parse engines cannot, because it uses a\ndifferent algorithm. The Earley algorithm is *general*, which means it can\nhandle *any* grammar you can define in BNF. In fact, the nearley syntax is\nwritten in *itself* (this is called bootstrapping).\n\nPEGjs and Jison are recursive-descent based, and so they will choke on a lot of\ngrammars, in particular [left recursive\nones](http://en.wikipedia.org/wiki/Left_recursion).\n\nnearley also has capabilities to catch errors gracefully, and detect ambiguous\ngrammars (grammars that can be parsed in multiple ways).\n\nInstallation and Usage\n----------------------\n\n> **Note:** For beginners, Guillermo Webster's\n> [nearley-playground](https://omrelli.ug/nearley-playground/) is a wonderful\n> way to explore nearley interactively in your browser:\n>\n> ![A screenshot of the playground](www/playground.png)\n> \n> Enjoy!\n\nTo use nearley, you need both a *global* and a *local* installation. The two\ntypes of installations are described separately below.\n\n---\n\nTo *compile* a nearley parser (a `.ne` file), you need to install the\n`nearleyc` command from npm:\n\n    $ npm install -g nearley\n    $ nearleyc parser.ne\n\nnearley ships with three additional tools:\n- `nearley-test` lets you quickly test a grammar against some input and see the\n  results. It also lets you explore the internal state of nearley's Earley\n  table, in case you find that interesting.\n- `nearley-unparse` inverts a parser into a generator, allowing you to create\n  random strings that match your grammar.\n- `nearley-railroad` generates pretty railroad diagrams from your parser. This\n  is mainly helpful for creating documentation, as (for example) on json.org.\n\nYou can uninstall the nearley compiler using `npm uninstall -g nearley`.\n\n---\n\nTo *use* a generated grammar, you need to install `nearley` as a per-project\ndependency via npm (note that there is no `-g` in the first command):\n\n```\n$ npm install nearley\n$ node\n> var nearley = require(\"nearley\");\n> var grammar = require(\"./my-generated-grammar.js\");\n```\n\nAlternatively, to use a generated grammar in a browser runtime, include the\n`nearley.js` file in a `<script>` tag.\n\n```html\n<script src=\"nearley.js\"></script>\n<script src=\"my-generated-grammar.js\"></script>\n```\n\n\nParser specification\n--------------------\n\nThis is a basic overview of nearley syntax and usage. For an advanced\nstyleguide, see [this file](how-to-grammar-good.md).\n\nA parser consists of several *nonterminals*, which are constructions in a\nlanguage. A nonterminal is made up of a series of either other nonterminals or\nstrings. In nearley, you define a nonterminal by giving its name and its\nexpansions.\n\nStrings are the *terminals*, which match those string literals (specified as\nJSON-compatible strings).\n\nThe following grammar matches a number, a plus sign, and another number:\n\n    expression -> number \"+\" number\n    \nAnything from a `#` to the end of a line is ignored as a comment:\n\n    expression -> number \"+\" number # sum of two numbers\n\nA nonterminal can have multiple expansions, separated by vertical bars (`|`):\n\n    expression ->\n          number \"+\" number\n        | number \"-\" number\n        | number \"*\" number\n        | number \"/\" number\n\nThe parser tries to parse the first nonterminal that you define in a file.\nHowever, you can (and should!) introduce more nonterminals as \"helpers\". In\nthis example, we would have to define the expansion of `number`.\n\n\n### Postprocessors\n\nEach meaning (called a *production rule*) can have a postprocessing function,\nthat can format the data in a way that you would like:\n\n```js\nexpression -> number \"+\" number {%\n    function (data, location, reject) {\n        return [\"sum\", data[0], data[2]];\n    }\n%}\n```\n\n`data` is an array whose elements match the nonterminals in order. The\npostprocessor `id` returns the first token in the match (literally\n`function(data) {return data[0];}`).\n\n`location` is the index at which that rule was found. Retaining this\ninformation in a syntax tree is useful if you're writing an interpreter and\nwant to give fancy error messages for runtime errors.\n\nIf, after examining the data, you want to force the rule to fail anyway, return\n`reject`. An example of this is allowing a variable name to be a word that is\nnot a string:\n\n```js\nvariable -> word {%\n    function(data, location, reject) {\n        if (KEYWORDS.indexOf(data[0]) === -1) {\n            return data[0]; // It's a valid name\n        } else {\n            return reject;  // It's a keyword, so reject it\n        }\n    }\n%}\n```\n\nYou can write your postprocessors in CoffeeScript by adding `@preprocessor\ncoffee` to the top of your file. Similarly, you can write them in TypeScript by\nadding `@preprocessor typescript` to the top of your file. If you would like to\nsupport a different postprocessor language, feel free to file a PR!\n\n### Epsilon rules\n\nThe **epsilon rule** is the empty rule that matches nothing. The constant\n`null` is the epsilon rule, so:\n\n    a -> null\n        | a \"cow\"\n\nwill match 0 or more `cow`s in a row.\n\n### Charsets\n\nYou can use valid RegExp charsets in a rule:\n\n    not_a_letter -> [^a-zA-Z]\n\nThe `.` character can be used to represent \"any character\".\n\n### EBNF\n\nnearley compiles some higher-level constructs into BNF for you. In particular,\nthe `*`, `?`, and `+` operators from Regexes (or EBNF) are available as shown:\n\n    batman -> \"na\":* \"batman\" # nananana...nanabatman\n\nYou can also use capture groups with parentheses. Its contents can be anything\nthat a rule can have:\n\n    banana -> \"ba\" (\"na\" {% id %} | \"NA\" {% id %}):+\n\n### Macros\n\nYou can create \"polymorphic\" rules through macros:\n\n    match3[X] -> $X $X $X\n    quote[X]  -> \"'\" $X \"'\"\n\n    main -> match3[quote[\"Hello?\"]]\n    # matches \"'Hello?''Hello?''Hello?'\"\n\nMacros are dynamically scoped:\n\n    foo[X, Y] -> bar[(\"moo\" | \"oink\" | \"baa\")] $Y\n    bar[Z]    -> $X \" \" $Z # 'remembers' $X from its caller\n    main -> foo[\"Cows\", \".\"]\n    # matches \"Cows oink.\" and \"Cows moo.\"\n\nMacros *cannot* be recursive (`nearleyc` will go into an infinite loop trying\nto expand the macro-loop).\n\n### Additional JS\n\nFor more intricate postprocessors, or any other functionality you may need, you\ncan include parts of literal JavaScript between production rules by surrounding\nit with `@{% ... %}`:\n\n```js\n@{% var makeCowWithString = require('./cow.js') %}\ncow -> \"moo\" {% function(d) {makeCowWithString(d[0]); } %}\n```\n\nNote that it doesn't matter where you define these; they all get hoisted to the\ntop of the generated code.\n\n### Importing\n\nYou can include the content of other parser files:\n\n    @include \"../misc/primitives.ne\" # path relative to file being compiled\n    sum -> number \"+\" number\n\nThere are also some built-in parsers whose contents you can include:\n\n    @builtin \"cow.ne\"\n    main -> cow:+\n\nSee the `builtin/` directory for an index of this library. Contributions are\nwelcome here!\n\nIncluding a parser imports *all* of the nonterminals defined in the parser, as\nwell as any JS, macros, and config options defined there.\n\n\n### Custom lexers\n\nYou can pass a `lexer` instance to Parser, which must have the following interface:\n\n* `reset(chunk, Info)`: set the internal buffer to `chunk`, and restore line/col/state info taken from `save()`.\n* `next() -> Token` return e.g. `{type, value, line, col, …}`. Only the `value` attribute is required.\n* `save() -> Info` -> return an object describing the current line/col etc. This allows us to preserve this information between `feed()` calls, and also to support `Parser#rewind()`. The exact structure is lexer-specific; nearley doesn't care what's in it.\n* `formatError(token)` -> return a string with an error message describing the line/col of the offending token. You might like to include a preview of the line in question.\n* `has(tokenType)` -> return true if the lexer can emit tokens with that name. Used to resolve `%`-specifiers in compiled nearley grammars.\n\nIf Parser isn't given a lexer option, it will look for a `.lexer` attribute on its Grammar. The `@lexer` directive allows exporting a lexer object from your `.ne` grammar file. (See `json.ne` for an example.)\n\n\n### Custom tokens\n\nNearley assumes by default that your fundamental unit of parsing, called a\n*token*, is a character. That is, you're parsing a list of characters. However,\nsometimes you want to preprocess your string to turn it into a list of *lexical\ntokens*. This means, instead of seeing \"1\", \"2\", \"3\", the nearley might just\nsee a single list item \"123\". This is called *tokenizing*, and it can bring you\ndecent performance gains. It also allows you to write cleaner, more\nmaintainable grammars and to prevent ambiguous grammars.\n\nTokens can be defined in two ways: literal tokens and testable tokens. A\nliteral token matches exactly, while a testable token runs a function to test\nwhether it is a match or not.\n\n```\n@{%\nvar print_tok  = {literal: \"print\"};\nvar number_tok = {test: function(x) {return x.constructor === Number; }}\n%}\n\nmain -> %print_tok %number_tok\n```\n\nNow, instead of parsing the string `\"print 12\"`, you would parse the array\n`[\"print\", 12]`.\n\nYou can write your own tokenizer using regular expressions, or choose from\nseveral existing tokenizing libraries for node.\n\n\nUsing a parser\n--------------\n\nnearley exposes the following API:\n\n```js\nvar grammar = require(\"generated-code.js\");\nvar nearley = require(\"nearley\");\n\n// Create a Parser object from our grammar.\nvar p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);\n\n// Parse something\np.feed(\"1+1\");\n// p.results --> [ [\"sum\", \"1\", \"1\"] ]\n```\n\nThe `Parser` object can be fed data in parts with `.feed(data)`. You can then\nfind an array of parsings with the `.results` property. If `results` is empty,\nthen there are no parsings. If `results` contains multiple values, then that\ncombination is ambiguous.\n\nThe incremental feeding design is inspired so that you can parse data from\nstream-like inputs, or even dynamic readline inputs. For example, to create a\nPython-style REPL where it continues to prompt you until you have entered a\ncomplete block.\n\n```js\np.feed(prompt_user(\">>> \"));\nwhile (p.results.length < 1) {\n    p.feed(prompt_user(\"... \"));\n}\nconsole.log(p.results);\n```\n\nThe `nearley.Parser` constructor takes an optional third parameter, `options`,\nwhich is an object with the following possible keys:\n\n- `keepHistory` (boolean, default `false`): if set to `true`, nearley will\n  preserve the internal state of the parser in the parser's `.table` property.\n  Preserving the state has some performance cost (because it can potentially be\n  very large), so we recommend leaving this as `false` unless you are familiar\n  with the Earley parsing algorithm and are planning to do something exciting\n  with the parse table.\n\nCatching errors\n---------------\n\nIf there are no possible parsings, nearley will throw an error whose `offset`\nproperty is the index of the offending token.\n\n```js\ntry {\n    p.feed(\"1+gorgonzola\");\n} catch(parseError) {\n    console.log(\n        \"Error at character \" + parseError.offset\n    ); // \"Error at character 2\"\n}\n```\n\n\nExploring a parser interactively\n--------------------------------\n\nThe global install will provide `nearley-test`, a simple command-line tool you\ncan use to inspect what a parser is doing. You input a generated `grammar.js`\nfile, and then give it some input to test the parser against. `nearley-test`\nprints out the output if successful, and also gives you the complete parse\ntable used by the algorithm. This is very helpful when you're testing a new\nparser.\n\nThis was previously called `bin/nearleythere.js` and written by Robin.\n\n\nThe Unparser\n------------\n\nThe Unparser takes a (compiled) parser and outputs a random string that would\nbe accepted by the parser.\n\n```\n$ nearley-unparse -s number <(nearleyc builtin/prims.ne)\n-6.22E94\n```\n\nYou can use the Unparser to...\n\n- ...test your parser specification by generating lots of random expressions\nand making sure all of them are \"correct\".\n- ...generate random strings from a schema (for example, random email addresses\nor telephone numbers).\n- ...create fuzzers and combinatorial stress-testers.\n- ...play \"Mad-Libs\" automatically! (Practical application: automatic\ngrammatically valid loremtext.)\n\nThe Unparser outputs as a stream by continuously writing characters to its\noutput pipe. So, if it \"goes off the deep end\" and generates a huge string, you\nwill still see output scrolling by in real-time.\n\nTo limit the size of the output, you can specify a bound on the depth with the\n`-d` flag. This switches the Unparser to a different algorithm. A larger depth\nbound corresponds to larger generated strings.\n\nAs far as I know, nearley is the only parser generator with this feature. It\nis inspired by Roly Fentanes' [randexp](https://fent.github.io/randexp.js/),\nwhich does the same thing with regular expressions.\n\n\nAutomagical Railroad Diagrams\n-----------------------------\n\nnearley lets you convert your grammars to pretty SVG railroad diagrams that you\ncan include in webpages, documentation, and even papers.\n\n```\n$ nearley-railroad regex.ne -o grammar.html\n```\n\n![Railroad demo](www/railroad-demo.png)\n\nSee a bigger example [here](http://nearley.js.org/www/railroad-demo.html).\n\n(This feature is powered by\n[`railroad-diagrams`](https://github.com/tabatkins/railroad-diagrams) by\ntabatkins.)\n\n\nOther Tools\n-----------\n\n*This section lists nearley tooling created by other developers. These tools\nare not distributed with nearley, so if you have problems, please contact the\nrespective author for support instead of opening an issue with nearley.*\n\nAtom users can write nearley grammars with [this\nplugin](https://github.com/bojidar-bg/nearley-grammar) by Bojidar Marinov.\n\nSublime Text users can write nearley grammars with [this\nsyntax](https://github.com/liam4/nearley-syntax-sublime) by liam4.\n\nVim users can use [this plugin](https://github.com/andres-arana/vim-nearley) by\nAndrés Arana.\n\nVisual Studio Code users can use [this\nextension](https://github.com/karyfoundation/nearley-vscode) by Pouya Kary.\n\nPython users can convert nearley grammars to Python using\n[lark](https://github.com/erezsh/lark#how-to-use-nearley-grammars-in-lark) by\nErez.\n\nBrowser users can use\n[nearley-playground](https://omrelli.ug/nearley-playground/) by Guillermo\nWebster to explore nearley interactively in the browser. There is also a [Mac\napp](https://github.com/pmkary/nearley-playground-mac) by Pouya Kary.\n\nWebpack users can use\n[nearley-loader](https://github.com/kozily/nearley-loader) by Andrés Arana to\nload grammars directly.\n\n\nStill confused?\n---------------\nYou can read [the calculator example](examples/calculator/arithmetic.ne) to get\na feel for the syntax (see it live\n[here](http://hardmath123.github.io/nearley/examples/calculator/)). You can\nread a grammar for [tosh](https://tosh.tjvr.org) over [here](examples/tosh.ne).\nThere are more sample grammars in the `/examples` directory. For larger\nexamples, we also have experimental parsers for **CSV** and **Lua**.\n\n\nContributing\n------------\n\nClone, hack, PR. Tests live in `test/` and can be called with `npm test`. Make\nsure you read `test/profile.log` after tests run, and that nothing has died\n(parsing is tricky, and small changes can kill efficiency).\n\nIf you're looking for something to do, here's a short list of things that would\nmake me happy:\n\n- Optimize. There are still plenty of optimizations that an enterprising\n  JS-savant could implement.\n- Help build the builtins library by PRing in your favorite primitives.\n- Solutions to issues labeled \"up for grabs\" on the issue tracker.\n\nNearley is MIT licensed.\n\nA big thanks to Nathan Dinsmore for teaching me how to Earley, Aria Stewart for\nhelping structure nearley into a mature module, and Robin Windels for\nbootstrapping the grammar. Additionally, Jacob Edelman wrote an experimental\nJavaScript parser with nearley and contributed ideas for EBNF support. Joshua\nT. Corbin refactored the compiler to be much, much prettier. Bojidar Marinov\nimplemented postprocessors-in-other-languages. Shachar Itzhaky fixed a subtle\nbug with nullables.\n\n\nFurther reading\n---------------\n\n- Read my [blog post](http://hardmath123.github.io/earley.html) to learn more\n  about the algorithm. \n- Read about [Marpa](http://savage.net.au/Marpa.html) to\n  learn more than you ever thought you wanted to know about parsing.\n- A [nearley\n  tutorial](https://medium.com/@gajus/parsing-absolutely-anything-in-javascript-using-earley-algorithm-886edcc31e5e)\n  written by @gajus.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hardmath123/nearley.git"
  },
  "scripts": {
    "benchmark": "node test/benchmark.js",
    "bootstrap": "node bin/nearleyc.js lib/nearley-language-bootstrapped.ne >lib/nearley-language-bootstrapped.js.new && mv lib/nearley-language-bootstrapped.js.new lib/nearley-language-bootstrapped.js",
    "test": "mocha test/launch.js"
  },
  "version": "2.10.0"
}
