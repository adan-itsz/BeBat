{
  "_args": [
    [
      {
        "raw": "nearley@^2.7.7",
        "scope": null,
        "escapedName": "nearley",
        "name": "nearley",
        "rawSpec": "^2.7.7",
        "spec": ">=2.7.7 <3.0.0",
        "type": "range"
      },
      "/home/adan/practicasWeb/beBat/node_modules/css-to-react-native"
    ]
  ],
  "_from": "nearley@>=2.7.7 <3.0.0",
  "_id": "nearley@2.10.3",
  "_inCache": true,
  "_location": "/nearley",
  "_nodeVersion": "8.2.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/nearley-2.10.3.tgz_1502304665428_0.6622026972472668"
  },
  "_npmUser": {
    "name": "hardmath123",
    "email": "hardmath123@comfortablynumbered.appspotmail.com"
  },
  "_npmVersion": "5.3.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "nearley@^2.7.7",
    "scope": null,
    "escapedName": "nearley",
    "name": "nearley",
    "rawSpec": "^2.7.7",
    "spec": ">=2.7.7 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/css-to-react-native"
  ],
  "_resolved": "https://registry.npmjs.org/nearley/-/nearley-2.10.3.tgz",
  "_shasum": "624cafc015558388bf8539b389dc31e04459e460",
  "_shrinkwrap": null,
  "_spec": "nearley@^2.7.7",
  "_where": "/home/adan/practicasWeb/beBat/node_modules/css-to-react-native",
  "author": {
    "name": "Hardmath123"
  },
  "bin": {
    "nearleyc": "bin/nearleyc.js",
    "nearley-test": "bin/nearley-test.js",
    "nearley-unparse": "bin/nearley-unparse.js",
    "nearley-railroad": "bin/nearley-railroad.js"
  },
  "bugs": {
    "url": "https://github.com/hardmath123/nearley/issues"
  },
  "contributors": "https://github.com/Hardmath123/nearley/graphs/contributors",
  "dependencies": {
    "nomnom": "~1.6.2",
    "railroad-diagrams": "^1.0.0",
    "randexp": "^0.4.2"
  },
  "description": "Simple, fast, powerful parser toolkit for JavaScript.",
  "devDependencies": {
    "@types/moo": "^0.3.0",
    "@types/node": "^7.0.27",
    "benchmark": "^2.1.3",
    "chai": "^3.4.1",
    "coffee-script": "^1.10.0",
    "doctoc": "^1.3.0",
    "microtime": "^2.1.2",
    "mocha": "^2.5.3",
    "moo": "^0.3.2",
    "typescript": "^2.3.4"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-GQjG6gQYgE/0ktAG8NGRLEVC/2CGFqjTim7bOvRNVUSbjmUe7X0GCY3Qa8OOc6MIIXNT9kg+RgiVfTxAk5m6tQ==",
    "shasum": "624cafc015558388bf8539b389dc31e04459e460",
    "tarball": "https://registry.npmjs.org/nearley/-/nearley-2.10.3.tgz"
  },
  "gitHead": "571ffa9b248048770306fa4490ab1237c4754a77",
  "homepage": "https://github.com/hardmath123/nearley#readme",
  "keywords": [
    "parser",
    "parse",
    "generator",
    "compiler",
    "compile",
    "grammar",
    "language"
  ],
  "license": "MIT",
  "main": "lib/nearley.js",
  "maintainers": [
    {
      "name": "hardmath123",
      "email": "hardmath123@comfortablynumbered.appspotmail.com"
    },
    {
      "name": "tjvr",
      "email": "tim@tjvr.org"
    }
  ],
  "name": "nearley",
  "optionalDependencies": {},
  "readme": "![](www/logo/nearley-purple.png)\n\n# [nearley](http://nearley.js.org)\n[![JS.ORG](https://img.shields.io/badge/js.org-nearley-ffb400.svg?style=flat-square)](http://js.org)\n[![npm version](https://badge.fury.io/js/nearley.svg)](https://badge.fury.io/js/nearley)\n\nnearley is a simple, fast and powerful parsing toolkit based on the [Earley\nalgorithm](https://en.wikipedia.org/wiki/Earley_parser).\n\nFor this reason, nearley can often parse what other JavaScript parsers simply\ncannot! nearley can handle *any* grammar you can define in BNF... and also some\ngrammars that you *cannot* define in BNF. Indeed, while most existing JS\nparsers such as PEGjs and Jison choke on certain grammars (in particular [left\nrecursive ones](http://en.wikipedia.org/wiki/Left_recursion)), nearley, handles\nthem easily and efficiently.\n\nnearley also has capabilities to catch errors gracefully, and deal with\nambiguous grammars (for strings that can be parsed in multiple ways). It comes\nwith fantastic tooling, and works in both node and the browser.\n\nnearley is used by a wide variety of projects:\n\n- [artificial\n  intelligence](https://github.com/ChalmersGU-AI-course/shrdlite-course-project)\n  and\n- [computational\n  linguistics](https://wiki.eecs.yorku.ca/course_archive/2014-15/W/6339/useful_handouts)\n  classes at universities;\n- [file format parsers](https://github.com/raymond-h/node-dmi);\n- [data-driven markup languages](https://github.com/idyll-lang/idyll-compiler);\n- [compilers for real programming languages](https://github.com/sizigi/lp5562);\n- and nearley itself! The nearley compiler is written in *itself*.\n\nnearley is an npm [staff\npick](https://www.npmjs.com/package/npm-collection-staff-picks).\n\n## Contents\n\n<!-- $ npm install -g doctoc -->\n<!-- $ doctoc --notitle README.md -->\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [Installation](#installation)\n- [Getting started: nearley in 3 steps](#getting-started-nearley-in-3-steps)\n- [Writing a parser](#writing-a-parser)\n  - [Terminals, nonterminals, rules](#terminals-nonterminals-rules)\n  - [Postprocessors](#postprocessors)\n    - [Target languages](#target-languages)\n  - [Catching errors](#catching-errors)\n  - [More syntax: tips and tricks](#more-syntax-tips-and-tricks)\n    - [Comments](#comments)\n    - [Charsets](#charsets)\n    - [Case-insensitive string literals](#case-insensitive-string-literals)\n    - [EBNF](#ebnf)\n  - [Macros](#macros)\n  - [Additional JS](#additional-js)\n  - [Importing other grammars](#importing-other-grammars)\n- [Tokenizers](#tokenizers)\n- [Tools](#tools)\n  - [nearley-test: Exploring a parser interactively](#nearley-test-exploring-a-parser-interactively)\n  - [nearley-unparse: The Unparser](#nearley-unparse-the-unparser)\n  - [nearley-railroad: Automagical Railroad Diagrams](#nearley-railroad-automagical-railroad-diagrams)\n  - [Other Tools](#other-tools)\n- [Still confused?](#still-confused)\n- [Contributing](#contributing)\n- [Further reading](#further-reading)\n  - [Documentation](#documentation)\n  - [Recipes](#recipes)\n  - [Details](#details)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n## Installation\n\nThe nearley *compiler* converts grammar definitions from a simple\n[BNF](https://en.wikipedia.org/wiki/Backusâ€“Naur_form)-based syntax to a small\nJS module. You can use that module to construct a nearley *parser*, which\nparses input strings.\n\nBoth components are published as a single\n[NPM](https://docs.npmjs.com/getting-started/what-is-npm) package compatible\nwith [Node.js](https://nodejs.org/en/) and most browsers.\n\nTo use the nearley *parser*, you need to install nearley **locally**.\n\n```bash\n$ npm install --save nearley\n```\n\nTo use the nearley *compiler*, you need to *additionally* install nearley\n**globally**.\n\n```bash\n$ npm install -g nearley\n```\nThis actually adds several new commands to your `$PATH`:\n\n- `nearleyc` compiles grammar files to JavaScript.\n- `nearley-test` lets you quickly test a grammar against some input and see the\n  results. It also lets you explore the internal state of nearley's Earley\n  table, in case you find that interesting.\n- `nearley-unparse` inverts a parser into a generator, allowing you to create\n  random strings that match your grammar.\n- `nearley-railroad` generates pretty railroad diagrams from your parser. This\n  is mainly helpful for creating documentation, as (for example) on json.org.\n\nThese are documented below.\n\n> NOTE: If you're not ready to install nearley yet, you can follow along in\n> your browser using the [nearley\n> playground](https://omrelli.ug/nearley-playground/), an online interface for\n> exploring nearley grammars interactively.\n\n## Getting started: nearley in 3 steps\n\nnearley was written with users in mind: getting started with nearley is as\nsimple as:\n\n**Step 1: Describe your grammar** using the nearley syntax. In a file called\n`grammar.ne`, write:\n\n```js\nmain -> (statement \"\\n\"):+\nstatement -> \"foo\" | \"bar\"\n```\n\n**Step 2: Compile** the grammar to a JavaScript module. On the command line,\nrun:\n\n```bash\n$ nearleyc grammar.ne -o grammar.js\n```\n\n**Step 3: Parse** some data! In a new JavaScript file, write:\n\n```js\nconst nearley = require(\"nearley\");\nconst grammar = require(\"./grammar.js\");\n\n// Create a Parser object from our grammar.\nconst parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n\n// Parse something!\nparser.feed(\"foo\\n\");\n\n// parser.results is an array of possible parsings.\nconsole.log(parser.results); // [[[[ \"foo\" ],\"\\n\" ]]]\n```\n\n## Writing a parser\n\nLet's explore the building blocks of a nearley parser.\n\n### Terminals, nonterminals, rules\n\n- A *terminal* is a string or a token. For example, the keyword `\"if\"` is a\n  terminal.\n- A *nonterminal* is a combination of terminals and other nonterminals. For\n  example, an if statement defined as `\"if\" condition statement` is a\n  nonteminal.\n- A *rule* (or production rule) is a definition of a nonterminal. For example,\n  `\"if\" condition \"then\" statement \"endif\"` is the rule according to which the\n  if statement nonterminal is parsed.\n\nThe first nonterminal of the grammar is the one the whole input must match.\nWith the following grammar, nearley will try to parse text as `expression`.\n\n```js\nexpression -> number \"+\" number\nnumber -> [0-9]:+\n```\n\nUse the pipe character `|` to separate alternative rules for a nonterminal.\n\n```js\nexpression ->\n      number \"+\" number\n    | number \"-\" number\n    | number \"*\" number\n    | number \"/\" number\n```\n\nThe keyword `null` stands for the **epsilon rule**, which matches nothing. The\nfollowing nonterminal matches zero or more `cow`s in a row, such as\n`cowcowcow`:\n\n```js\na -> null\n    | a \"cow\"\n```\n\nKeep in mind that nearley syntax is not sensitive to formatting. You're welcome\nto keep rules on the same line: `foo -> bar | qux`.\n\n### Postprocessors\n\nBy default, nearley wraps everything matched by a rule into an array. For\nexample, when `rule -> \"foo\" \"bar\"` matches, it creates the \"parse tree\"\n`[\"foo\", \"bar\"]`.  Most of the time, however, you need to process that data in\nsome way: for example, you may want to filter out whitespace, or transform the\nresults into a custom JavaScript object.\n\nFor this purpose, each rule can have a *postprocessor*: a JavaScript function\nthat transforms the array and returns a \"processed\" version of the result.\nPostprocessors are wrapped in `{% %}`:\n\n```js\nexpression -> number \"+\" number {%\n    function(data, location, reject) {\n        return {\n            operator: \"sum\",\n            leftOperand: data[0],\n            rightOperand: data[2] // data[1] is \"+\"\n        };\n    }\n%}\n```\n\nThe rule above will parse the string `5+10` into `{ operator: \"sum\",\nleftOperand: \"5\", rightOperand: \"10\" }`.\n\nThe postprocessor can be any function. It will be passed three arguments:\n\n- `data: Array` - an array that contains the results of parsing each part of\n  the rule. Note that it is still an array, even if the rule only has one part!\n  You can use the built-in `{% id %}` postprocessor to convert a one-item array\n  into the item itself.\n- `location: number` - the index (zero-based) at which the rule match starts.\n  This is useful, for example, to construct an error message that tells you where\n  in the source the error occurred.\n- `reject: Object` - return this object to signal that this rule doesn't\n  *actually* match. This is necessary in certain edge-conditions. For example,\n  suppose you want sequences of letters to match variables, except for the\n  keyword `var`. In this case, your rule may be\n  ```js\n  word -> [a-z]:+ {%\n      function(d,l, reject) {\n          if (d[0] == 'var') {\n              return reject;\n          } else {\n              return {'var': d[0]};\n          }\n      }\n  %}\n  ```\n  Please note that grammars using `reject` are not context-free, and are often\n  much slower to parse. Use it wisely! You can usually avoid the need for\n  `reject` by using a [tokenizer](#tokenizers).\n\nRemember that a postprocessor is scoped to a single rule, not the whole\nnonterminal. If a nonterminal has multiple alternative rules, each of them can\nhave its own postprocessor.\n\nFor arrow-function users, a convenient pattern is to decompose the `data` array\nwithin the argument of the arrow function:\n\n```js\nexpression ->\n      number \"+\" number {% ([first, _, second]) => first + second %}\n    | number \"-\" number {% ([first, _, second]) => first - second %}\n    | number \"*\" number {% ([first, _, second]) => first * second %}\n    | number \"/\" number {% ([first, _, second]) => first / second %}\n```\n\nThere are two built-in postprocessors for the most common scenarios:\n\n- `id` - returns the first element of the `data` array. This is useful to\n  extract the content of a single-element array: `foo -> bar {% id %}`\n\n- `nuller` - returns null. This is useful for whitespace rules: `space -> \" \"\n  {% nuller %}`\n\n#### Target languages\n\nBy default, `nearleyc` compiles your grammar to JavaScript. You can also choose\nCoffeeScript or TypeScript by adding `@preprocessor coffee` or `@preprocessor\ntypescript` at the top of your grammar file. This can be useful to write your\npostprocessors in a different language, and to get type annotations if you wish\nto use nearley in a statically typed dialect of JavaScript.\n\n### Catching errors\n\nnearley is a *streaming* parser: you can keep feeding it more strings. This\nmeans that there are two error scenarios in nearley.\n\nConsider the simple parser below for the examples to follow.\n\n```js\nmain -> \"Cow goes moo.\" {% function(d) {return \"yay!\"; } %}\n```\n\nIf there are no possible parsings given the current input, but in the *future*\nthere *might* be results if you feed it more strings, then nearley will\ntemporarily set the `results` array to the empty array, `[]`.\n\n```js\nparser.feed(\"Cow \");  // parser.results is []\nparser.feed(\"goes \"); // parser.results is []\nparser.feed(\"moo.\");  // parser.results is [\"yay!\"]\n```\n\nIf there are no possible parsings, and there is no way to \"recover\" by feeding\nmore data, then nearley will throw an error whose `offset` property is the\nindex of the offending token.\n\n```js\ntry {\n    parser.feed(\"Cow goes% moo.\");\n} catch(parseError) {\n    console.log(\"Error at character \" + parseError.offset); // \"Error at character 9\"\n}\n```\n\n### More syntax: tips and tricks\n\n#### Comments\n\nComments are marked with '#'. Everything from `#` to the end of a line is\nignored:\n\n```ini\nexpression -> number \"+\" number # sum of two numbers\n```\n\n#### Charsets\n\nYou can use valid RegExp charsets in a rule (unless you're using a\n[tokenizer](#tokenizers)):\n\n    not_a_letter -> [^a-zA-Z]\n\nThe `.` character can be used to represent any character.\n\n#### Case-insensitive string literals\n\nYou can create case-insensitive string literals by adding an `i` after the\nstring literal:\n\n    cow -> \"cow\"i # matches CoW, COW, and so on.\n\nNote that if you are using a lexer, your lexer should use the `i` flag in its\nregexes instead. That is, if you are using a lexer, you should *not* use the\n`i` suffix in nearley.\n\n#### EBNF\n\nnearley supports the `*`, `?`, and `+` operators from\n[EBNF](https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_form) as shown:\n\n```ini\nbatman -> \"na\":* \"batman\" # nananana...nanabatman\n```\n\nYou can also use capture groups with parentheses. Its contents can be anything\nthat a rule can have:\n\n```js\nbanana -> \"ba\" (\"na\" {% id %} | \"NA\" {% id %}):+\n```\n\n### Macros\n\nMacros allow you to create polymorphic rules:\n\n```ini\n# Matches \"'Hello?' 'Hello?' 'Hello?'\"\nmain -> matchThree[inQuotes[\"Hello?\"]]\n\nmatchThree[X] -> $X \" \" $X \" \" $X\n\ninQuotes[X] -> \"'\" $X \"'\"\n```\n\nMacros are dynamically scoped, which means they see arguments passed to parent\nmacros:\n\n```ini\n# Matches \"Cows oink.\" and \"Cows moo!\"\nmain -> sentence[\"Cows\", (\".\" | \"!\")]\n\nsentence[ANIMAL, PUNCTUATION] -> animalGoes[(\"moo\" | \"oink\" | \"baa\")] $PUNCTUATION\n\nanimalGoes[SOUND] -> $ANIMAL \" \" $SOUND # uses $ANIMAL from its caller\n```\n\nMacros are expanded at compile time and inserted in places they are used. They\nare not \"real\" rules. Therefore, macros *cannot* be recursive (`nearleyc` will\ngo into an infinite loop trying to expand the macro-loop).\n\n### Additional JS\n\nFor more intricate postprocessors, or any other functionality you may need, you\ncan include chunks of JavaScript code between production rules by surrounding\nit with `@{% ... %}`:\n\n```js\n@{%\nconst cowSays = require(\"./cow.js\");\n%}\n\ncow -> \"moo\" {% ([moo]) => cowSays(moo) %}\n```\n\nNote that it doesn't matter where you add these; they all get hoisted to the\ntop of the generated code.\n\n### Importing other grammars\n\nYou can include the content of other grammar files:\n\n```ini\n@include \"../misc/primitives.ne\" # path relative to file being compiled\nsum -> number \"+\" number # uses \"number\" from the included file\n```\n\nThere are several builtin helper files that you can include:\n\n```ini\n@builtin \"cow.ne\"\nmain -> cow:+\n```\n\nSee the [`builtin/`](builtin) directory for more details. Contributions are\nwelcome here!\n\nIncluding a file imports *all* of the nonterminals defined in it, as well as\nany JS, macros, and config options defined there.\n\n## Tokenizers\n\nBy default, nearley splits the input into a stream of characters. This is\ncalled *scannerless* parsing.\n\nA tokenizer splits the input into a stream of larger units called *tokens*.\nThis happens in a separate stage before parsing. For example, a tokenizer might\nconvert `512 + 10` into `[\"512\", \"+\", \"10\"]`: notice how it removed the\nwhitespace, and combined multi-digit numbers into a single number.\n\nUsing a tokenizer has many benefits. It...\n\n- ...often makes your parser faster by more than an order of magnitude.\n- ...allows you to write cleaner, more maintainable grammars.\n- ...helps avoid ambiguous grammars in some cases. For example, a tokenizer can\n  easily tell you that `superclass` is a single keyword, not a sequence of\n  `super` and `class` keywords.\n- ...gives you *lexical information* such as line numbers for each token. This\n  lets you make better error messages.\n\nnearley supports and recommends [Moo](https://github.com/tjvr/moo), a\nsuper-fast tokenizer. Here is a simple example:\n\n```coffeescript\n@{%\nconst moo = require(\"moo\");\n\nconst lexer = moo.compile({\n  ws:     /[ \\t]+/,\n  number: /[0-9]+/,\n  times:  /\\*|x/\n});\n%}\n\n# Pass your lexer object using the @lexer option:\n@lexer lexer\n\n# Use %token to match any token of that type instead of \"token\":\nmultiplication -> %number %ws %times %ws %number {% ([first, , , , second]) => first * second %}\n```\n\nHave a look at [the Moo documentation](https://github.com/tjvr/moo#usage) to\nlearn more about the tokenizer.\n\nNote that when using a tokenizer, raw strings match full tokens parsed by Moo.\nThis is convenient for matching keywords.\n\n```ini\nifStatement -> \"if\" condition \"then\" block\n```\n\nYou use the parser as usual: call `parser.feed(data)`, and nearley will give\nyou the parsed results in return.\n\n\n## Tools\n\nAs mentioned above, nearley ships with a host of tools.\n\n### nearley-test: Exploring a parser interactively\n\nA global install of nearley provides `nearley-test`, a simple command-line tool\nyou can use to inspect what a parser is doing. You input a generated\n`grammar.js` file, and then give it some input to test the parser against.\n`nearley-test` prints out the output if successful, and optionally\npretty-prints the internal parse table used by the algorithm. This is helpful\nto test a new parser.\n\n### nearley-unparse: The Unparser\n\nThe Unparser takes a (compiled) parser and outputs a random string that would\nbe accepted by the parser.\n\n```bash\n$ nearley-unparse -s number <(nearleyc builtin/prims.ne)\n-6.22E94\n```\n\nYou can use the Unparser to...\n\n- ...test your parser specification by generating lots of random expressions\n  and making sure all of them are \"correct\".\n- ...generate random strings from a schema (for example, random email addresses\n  or telephone numbers).\n- ...create fuzzers and combinatorial stress-testers.\n- ...play \"Mad-Libs\" automatically! (Practical application: automatic\n  grammatically valid loremtext.)\n\nThe Unparser outputs as a stream by continuously writing characters to its\noutput pipe. So, if it \"goes off the deep end\" and generates a huge string, you\nwill still see output scrolling by in real-time.\n\nTo limit the size of the output, you can specify a bound on the depth with the\n`-d` flag. This switches the Unparser to a different algorithm. A larger depth\nbound corresponds to larger generated strings.\n\nAs far as I know, nearley is the only parser generator with this feature. It\nis inspired by Roly Fentanes' [randexp](https://fent.github.io/randexp.js/),\nwhich does the same thing with regular expressions.\n\n### nearley-railroad: Automagical Railroad Diagrams\n\nnearley lets you convert your grammars to pretty SVG railroad diagrams that you\ncan include in webpages, documentation, and even papers.\n\n```bash\n$ nearley-railroad regex.ne -o grammar.html\n```\n\n![Railroad demo](www/railroad-demo.png)\n\nSee a bigger example [here](http://nearley.js.org/www/railroad-demo.html).\n\n(This feature is powered by\n[`railroad-diagrams`](https://github.com/tabatkins/railroad-diagrams) by\ntabatkins.)\n\n### Other Tools\n\n*This section lists nearley tooling created by other developers. These tools\nare not distributed with nearley, so if you have problems, please contact the\nrespective author for support instead of opening an issue with nearley.*\n\nAtom users can write nearley grammars with [this\nplugin](https://github.com/bojidar-bg/nearley-grammar) by Bojidar Marinov.\n\nSublime Text users can write nearley grammars with [this\nsyntax](https://github.com/liam4/nearley-syntax-sublime) by liam4.\n\nVim users can use [this plugin](https://github.com/andres-arana/vim-nearley) by\nAndrÃ©s Arana.\n\nVisual Studio Code users can use [this\nextension](https://github.com/karyfoundation/nearley-vscode) by Pouya Kary.\n\nPython users can convert nearley grammars to Python using\n[lark](https://github.com/erezsh/lark#how-to-use-nearley-grammars-in-lark) by\nErez.\n\nBrowser users can use\n[nearley-playground](https://omrelli.ug/nearley-playground/) by Guillermo\nWebster to explore nearley interactively in the browser. There is also a [Mac\napp](https://github.com/pmkary/nearley-playground-mac) by Pouya Kary.\n\nWebpack users can use\n[nearley-loader](https://github.com/kozily/nearley-loader) by AndrÃ©s Arana to\nload grammars directly.\n\nGulp users can use\n[gulp-nearley](https://github.com/JosephJNK/gulp-nearley) by Joseph Junker to\ncompile grammars with a gulpfile.\n\n## Still confused?\n\nYou can read [the calculator example](examples/calculator/arithmetic.ne) to get\na feel for the syntax (see it live\n[here](http://hardmath123.github.io/nearley/examples/calculator/)). You can\nread a grammar for [tosh](https://tosh.tjvr.org) over [here](examples/tosh.ne).\nThere are more sample grammars in the `/examples` directory. For larger\nexamples, we also have experimental parsers for **CSV** and **Lua**.\n\n## Contributing\n\nTests live in `test/` and can be called with `npm test`. Please run the\nbenchmarks before and after your changes: parsing is tricky, and small changes\ncan kill efficiency. We learned this the hard way!\n\nIf you're looking for something to do, here's a short list of things that would\nmake me happy:\n\n- Optimize. There are still plenty of optimizations that an enterprising\n  JS-savant could implement.\n- Help build the builtins library by PRing in your favorite primitives.\n- Solutions to issues labeled \"up for grabs\" on the issue tracker.\n\nNearley is MIT licensed.\n\nA big thanks to Nathan Dinsmore for teaching me how to Earley, Aria Stewart for\nhelping structure nearley into a mature module, and Robin Windels for\nbootstrapping the grammar. Additionally, Jacob Edelman wrote an experimental\nJavaScript parser with nearley and contributed ideas for EBNF support. Joshua\nT. Corbin refactored the compiler to be much, much prettier. Bojidar Marinov\nimplemented postprocessors-in-other-languages. Shachar Itzhaky fixed a subtle\nbug with nullables.\n\n## Further reading\n\n### Documentation\n\n- [Best practices for writing grammars](docs/how-to-grammar-good.md)\n- [More on tokenizers](docs/custom-tokens-and-lexers.md)\n- [Accessing the internal parse table](docs/accessing-parse-table.md)\n- [Using `nearleyc` in browsers](docs/using-in-frontend.md)\n\n### Recipes\n\n- [Transforming parse trees](docs/generating-cst-ast.md)\n- [Writing an indentation-aware (Python-like) lexer](https://gist.github.com/nathan/d8d1adea38a1ef3a6d6a06552da641aa)\n- [Making a REPL for your language](docs/making-a-repl.md)\n\n### Details\n\n- Read my [blog post](http://hardmath123.github.io/earley.html) to learn more\n  about the algorithm.\n- Read about [Marpa](http://savage.net.au/Marpa.html) to\n  learn more than you ever thought you wanted to know about parsing.\n- A [nearley\n  tutorial](https://medium.com/@gajus/parsing-absolutely-anything-in-javascript-using-earley-algorithm-886edcc31e5e)\n  written by @gajus.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hardmath123/nearley.git"
  },
  "scripts": {
    "benchmark": "node test/benchmark.js",
    "bootstrap": "bin/nearleyc.js lib/nearley-language-bootstrapped.ne > tmp && mv tmp lib/nearley-language-bootstrapped.js",
    "doctoc": "doctoc --notitle README.md",
    "test": "mocha test/launch.js"
  },
  "version": "2.10.3"
}
